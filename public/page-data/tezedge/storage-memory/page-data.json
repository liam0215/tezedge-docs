{"componentChunkName":"component---src-templates-post-template-js","path":"/tezedge/storage-memory","result":{"data":{"markdownRemark":{"fields":{"slug":"/tezedge/storage-memory"},"id":"c81774b3-e030-5dcd-8594-198e4c57a98e","html":"<h1 id=\"storage-memory\" style=\"position:relative;\"><a href=\"#storage-memory\" aria-label=\"storage memory permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Storage memory</h1>\n<p>Memory management is one of the most crucial aspects of programming since it controls the way a software application accesses computer memory. A software requires access to the computer's random access memory (RAM) to:</p>\n<ul>\n<li>Load its own bytecode that needs to be executed.Store the data values and structures that's been used by the program</li>\n<li>Load any run-time systems that are required for the program to execute.</li>\n<li>Unlike hard disk drives, RAM is finite.</li>\n</ul>\n<p>Unlike hard disk drives, RAM is finite. If a program keeps consuming memory without freeing it, we may reach a position where the system itself runs out of memory and crashes.</p>\n<p>To avoid this, memory must be efficiently managed. One way of achieving that is garbage collection.</p>\n<p><strong>The Importance Of Garbage Collection</strong></p>\n<p>A garbage collector's function is to reclaim garbage or the memory occupied by objects that are no longer in use by the program.</p>\n<p>Garbage collection can potentially be a cumbersome process as it takes up a significant portion of total processing time in a program and has significant influence on the system’s performance. Garbage collection usually occurs when one of the following conditions is observed:</p>\n<ul>\n<li>The overall system has low physical memory. This can be detected either by a low memory notification from your OS or can be indicated by the host.</li>\n<li>The memory allocated to objects on the managed heap has surpassed an acceptable threshold.</li>\n</ul>\n<p>JVM(Java/Scala/Groovy/Kotlin), JavaScript, C#, Golang, Ruby, and OCaml, and Ruby are some of the languages that use Garbage collection for memory management by default.</p>\n<p><strong>Stack vs Heap</strong></p>\n<p>Before we go deeper into garbage collection, let's gain a little more clarity on how computer memory works. Regardless of what language you are running, when a program gets executed, a particular amount of memory is allocated on your RAM to make space for variables, computations, etc. This space can be in on of the two following spaces:</p>\n<ul>\n<li><strong>Stack:</strong> The items on the stack are managed by the CPU upon compilation. Everytime a variable is created, it gets pushed onto the stack. A stack follows the LIFO (Last In First Out) principle Simply put, when the program ends, the system automatically clears the stack by removing the last item first. The stack mostly holds local variables of primitive data types like ints, booleans, etc.</li>\n<li><strong>Heap:</strong> Unlike the stack, the heap is not managed by the CPU and is managed by the programmer themselves. The biggest problem with heap is that the programmer has to be constantly aware of where, why, and how much memory you are working with at all times. However, it isn't limited to the size of the variables and has more space than the stack.</li>\n</ul>\n<p><strong>Memory Release Via Garbage Collection</strong></p>\n<p>The main objective of Garbage Collector is to free heap memory by removing unreachable objects. The garbage collector determines the best time to perform a collection based on the memory allocations being made. When the garbage collector performs a collection, it:</p>\n<ul>\n<li>Releases the memory for objects that are no longer being used by the application.</li>\n<li>Determines which objects are no longer being used by examining the application's roots.</li>\n</ul>\n<p>An application's roots include static fields, local variables on a thread's stack, CPU registers, GC handles, and the finalize queue. The garbage collector can ask the rest of the runtime for these roots.</p>\n<p>Based on this list, the GC creates a graph that contains all the objects that are within the root's reach. The objects that are unreachable for this graph are considered garbage, and the allocator promptly releases the memory associated with them<strong>.</strong></p>\n<p><strong>What happens during garbage collection?</strong></p>\n<ol>\n<li>The garbage collector examines the managed heap, looking for the blocks of address space occupied by unreachable objects.</li>\n<li>Upon discovering an unreachable object, the garbage collector uses a memory-copying function to compact the reachable objects in memory, freeing up the blocks of address spaces allocated to unreachable objects.</li>\n<li>After these reachable objects have been compacted, the garbage collector makes the necessary pointer corrections so that the application's roots point to the objects in their new locations.</li>\n<li>Memory is compacted only if the GC discovers a significant number of unreachable objects.</li>\n<li>If all the objects in a managed heap survive the collection process, there is no need for memory compaction.</li>\n<li>To improve performance, the runtime allocates memory for large objects in a separate heap. The GC automatically releases the memory for large objects. However, this memory usually isn't compacted to avoid moving large objects in memory.</li>\n</ol>\n<p><strong>Improving upon manual memory allocation?</strong></p>\n<p>There are several reasons we prefer using an integrated garbage collector instead of allocating memory manually. For a better perspective, let's compare your standard garbage collection with C's free() function. Free() is used in C to dynamically deallocate the memory.</p>\n<ul>\n<li>Firstly, free() is a very expensive operation, which involves navigating over the complex data structures used by the memory allocator.</li>\n<li>Whenever you call free(), all of the code and data gets loaded into the cache, which inadvertently displaces them every single time you free a single memory allocation.</li>\n<li>On the other hand, a garbage collector can free up multiple memory areas in one go, which makes the system displace code and data only once, making it far more efficient.</li>\n<li>Garbage collectors also move memory areas around and compact the overall heap, making allocation easier and faster.</li>\n</ul>\n<p><strong>Garbage Collection vs. Automatic Reference Counting</strong></p>\n<p>Memory management usually takes place via two methods – Garbage Collection and Automatic Reference Counting (ARC). Like GC, ARC also aims to take the burden of memory management away from the programmers. Languages like Objective-C, Swift, and Perl use the ARC for memory management.</p>\n<p>The core principle of ARC is simple: an object is considered needed as long as some piece of code is holding on to it. This is how it works:</p>\n<ul>\n<li>ARC counts the number of references for each object. When the reference count drops to zero, the object is deemed unreachable and recycled.</li>\n<li>During compilation, the ARC inserts messages like retain and release on to the objects which increases or decreases its reference count at runtime.</li>\n<li>When the number of references goes down to zero, the object gets marked for deallocation.</li>\n<li>Unlike GC, ARC isn't a background process. Plus, it removes objects asynchronously at runtime.</li>\n</ul>\n<p>While reference counting does have its moments, many computer scientists don't consider it \"serious\" garbage collecting. The ARC system has the following disadvantages:</p>\n<ul>\n<li>Each object needs to store a reference count.</li>\n<li>Programs end up using more memory and are consequently slower.</li>\n<li>Reference counting is expensive since you need to constantly update and check the references of each object during runtime.</li>\n<li>They cannot collect so-called circular, or self-referential structures.</li>\n</ul>\n<p><strong>Advantages of a garbage collection</strong></p>\n<ul>\n<li>It frees up programmers from having to manually release memory, enabling them to channel their focus on more important functions.</li>\n<li>It allocates objects on the managed heap more efficiently.</li>\n<li>Objects that are no longer users are reclaimed, cleared of their memory, and the GC reserves the memory for future allocation.</li>\n<li>Constructors don't need to initialize every data field since managed objects get to automatically start with fresh content.</li>\n<li>By making sure that an object cannot use the content of another object, it provides memory safety.</li>\n</ul>\n<p><strong>Garbage collection and OCaml</strong></p>\n<p>Tezos' underlying protocol has been written in OCaml. As with most of the modern languages, it has an integrated garbage collector which can do the garbage collection process for you. This garbage collector is a modern hybrid generational/incremental collector which outperforms manual collection in most cases.</p>\n<p>The OCaml garbage collector is synchronous and doesn't run in a separate thread. It can only get called during an allocation request. OCaml's garbage collector has two heaps – the minor heap and the major heap.</p>\n<ul>\n<li><strong>Minor Heap:</strong> Most objects are small, get allocated frequently and then immediately freed. These objects enter the minor heap and get promptly freed up by the garbage collector.</li>\n<li><strong>Major Heap:</strong> Only a few objects are more long lasting. These objects get shifted into the major heap from the minor heap after a certain amount of time. The major heap gets cleaned up less frequently than the minor heap.</li>\n</ul>\n<p><strong>The Garbage Collection module in OCaml</strong></p>\n<p>OCaml's GC module has some useful functions for querying and calling the garbage collector. to understand how all this works, consider the following program:</p>\n<p>let rec iterate r x_init i =</p>\n<p>if i = 1 then x_init</p>\n<p>else</p>\n<p>let x = iterate r x_init (i-1) in</p>\n<p>r *. x *. (1.0 -. x)</p>\n<p>let () =</p>\n<p>Random.self_init ();</p>\n<p>Graphics.open_graph \" 640x480\";</p>\n<p>for x = 0 to 640 do</p>\n<p>let r = 4.0 *. (float<em>of</em>int x) /. 640.0 in</p>\n<p>for i = 0 to 39 do</p>\n<p>let x_init = Random.float 1.0 in</p>\n<p>let x<em>final = iterate r x</em>init 500 in</p>\n<p>let y = int<em>of</em>float (x_final *. 480.) in</p>\n<p>Graphics.plot x y</p>\n<p>done</p>\n<p>done;</p>\n<p>Gc.print_stat stdout</p>\n<p><strong>The code above, will print out the following:</strong></p>\n<p>minor_words: 115926165 # Total number of words allocated</p>\n<p>promoted_words: 31217 # Promoted from minor -> major</p>\n<p>major_words: 31902 # Large objects allocated in major directly</p>\n<p><strong>minor_collections: 3538</strong> # Number of minor heap collections</p>\n<p><strong>major_collections: 39</strong> # Number of major heap collections</p>\n<p>heap_words: 63488 # Size of the heap, in words = approx. 256K</p>\n<p>heap_chunks: 1</p>\n<p>top<em>heap</em>words: 63488</p>\n<p>live_words: 2694</p>\n<p>live_blocks: 733</p>\n<p>free_words: 60794</p>\n<p>free_blocks: 4</p>\n<p>largest_free: 31586</p>\n<p>fragments: 0</p>\n<p>compactions: 0</p>\n<p>There are two things that you should note in the block of content above. The minor heap has around 3,538 collections, while the major heap has only 39. In this simple example, we can see that the minor heap is nearly 100X times bigger than the major heap.</p>\n<p><strong>Minor Heap Garbage Collection in OCaml</strong></p>\n<p>First, let's see how the minor heap works in OCaml. As mentioned before, the minor heap is where most of the short-lived values are held. In the minor heap, we have a sequence of OCaml blocks in one chunk of virtual memory.</p>\n<p>Here are some points to keep in mind about the minor heap:</p>\n<ul>\n<li>OCaml uses copying collection to move all live blocks in the minor heap to the major heap. The work needed here is proportional to the number of live blocks in the minor heap. As per definition, the number of blocks in the minor heap is generally small.</li>\n<li>The minor collection halts the application while it runs. This is why it's very important that it finishes quickly to minimize interruptions.</li>\n</ul>\n<p><strong>How does garbage collection work in minor heaps?</strong></p>\n<ul>\n<li>There are two pointers that delimit the start and end of the heap region – caml<em>young</em>start (start) and caml<em>young</em>end (end).</li>\n<li>In a fresh minor heap, the current pointer (ptr) will point at the end, while the \"limit\" is equal to \"start.\"</li>\n<li>As blocks get allocated, the ptr value will keep decreasing until it reaches the \"limit.\" When the limit is reached, the minor heap garbage collection gets triggered.</li>\n</ul>\n<p><strong>Major Heap Garbage Collection in OCaml</strong></p>\n<p>The major heap is much larger in size than the minor heap and scales up several gigabytes in size. It is cleaned using a mark-and-sweep garbage collection algorithm. This is how it works:</p>\n<ul>\n<li>During the mark phase, the algorithm scans the block graph and marks all live blocks by setting a bit in the tag of the block header. This tag is also known as the color tag.</li>\n<li>During the sweep phase, it sequentially scans the heap chunks and identifies dead blocks that haven't been marked earlier.</li>\n</ul>\n<p>Like the minor heap, major heap garbage collection also needs to stop the application to conduct its operations. As such, the mark-and-sweep phases run incrementally over slices of the heap to avoid frequent pausing.</p>\n<p><strong>Garbage Collection in the TezEdge node</strong></p>\n<p>The Rust-based TezEdge node has begun development on a garbage collector for its storage. The primary reason behind this is a desire to increase the node’s performance by storing the blockchain state in memory. However, since memory is limited and expensive, it is necessary to efficiently manage it, with GC being one way of achieving that.</p>\n<p>Two constraints for the GC implementation were identified:</p>\n<ol>\n<li>The node needs to store at least the last 7 cycles in memory in order to function properly.</li>\n<li>The GC must not slow down the node’s storage to the point where switching to an in-memory implementation does not improve performance.</li>\n</ol>\n<p>The approach that has so far delivered the best results utilizes a so-called mark and move approach. The 7 most recent cycles are divided into 7 cycle stores, necessary entries from older cycles are periodically ‘moved’ to the new cycle stores and everything else gets garbage collected. For more detailed information, illustrated diagrams and a discussion of the process, please read the <a href=\"https://docs.tezedge.com/tezedge/garbage-collection\">TezEdge garbage collection article.</a></p>\n<p><strong>Bibliography</strong></p>\n<p>Madhavapeddy, Anil, Hickey, Jason, and Minsky, Yaron. “Real World OCaml,” in <a href=\"https://dev.realworldocaml.org/\">https://dev.realworldocaml.org/</a>, 2013.</p>\n<p>“Garbage Collection,” in <a href=\"https://ocaml.org/learn/tutorials/garbage_collection.html\">https://ocaml.org/learn/tutorials/garbage_collection.html</a>.</p>\n<p>“Fundamentals of garbage collection,” in <a href=\"https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/\">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/</a>.</p>\n<p>Zorn, Benjamin. \"The Measured Cost of Conservative Garbage Collection\"in <a href=\"https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380230704\">https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380230704</a>, 1993.</p>\n<p>“Garbage Collection in Java,” in <a href=\"https://www.geeksforgeeks.org/garbage-collection-java/\">https://www.geeksforgeeks.org/garbage-collection-java/</a>.</p>","frontmatter":{"date":null,"title":"Storage memory","sidebar":"Docs","showTitle":false,"hideAnchor":null}}},"pageContext":{}},"staticQueryHashes":["1006376404","1936182646","3649515864"]}