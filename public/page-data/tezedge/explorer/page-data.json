{"componentChunkName":"component---src-templates-post-template-js","path":"/tezedge/explorer","result":{"data":{"markdownRemark":{"fields":{"slug":"/tezedge/explorer"},"id":"e5a0cb35-ae6c-552b-8405-588cf7f9e485","html":"<h1 id=\"explorer\" style=\"position:relative;\"><a href=\"#explorer\" aria-label=\"explorer permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Explorer</h1>\n<p><em>The TezEdge Explorer is an in-depth node explorer that shows all interactions between the Tezos protocol and storage. Developers, security researchers and other users can use the TezEdge Explorer to audit, trace and profile each individual action occurring within a block.</em></p>\n<p>In coding, most bugs occur due to an incomplete understanding of the code that is being utilized. Tracing and profiling can help with that.</p>\n<p>Tracing is used to track individual actions performed within the code. With profiling, you can view which code is using the most resources.</p>\n<p>Through tracing and profiling, you can gain a deeper understanding of an application, which results in code that performs well and runs smoothly, without errors or bugs. In case there is an error, detailed logging helps you quickly find and fix the error in question.</p>\n<p>In our case, we’ve decided to provide an application that reveals the interactions between the Tezos protocol and storage.</p>\n<p><strong>The interactions between protocol and storage</strong></p>\n<p>In blockchain, the storage module is responsible for holding the data (values) from validated blocks. The Tezos storage organizes these values into a tree structure, in which each key represents a path to a value.</p>\n<p>Blocks are created from a sequence of actions. There are two categories of actions for reading from and writing into the storage. The sum of these actions results in a block which is recorded into the storage.</p>\n<p>Usually, block explorers show the sum of these actions, but not the complete sequence of the read and write actions in the storage.</p>\n<p><strong>Tezos node explorer</strong></p>\n<p>With TezEdge, we’ve developed an in-depth<a href=\"http://tezedge.com\"> node explorer</a> that displays every action occurring within the block, displaying its key (pathway) as well as the values it either reads from or writes into the storage.</p>\n<p>This tool is of particular use for developers and security researchers as it allows them to audit, trace and profile each individual action occurring within a block.</p>\n<p><em>In its current early alpha version, users can search by blocks and addresses.</em></p>\n<p>Explorer1.gif</p>\n<p><em>This animation demonstrates searching by smart contract address. It will filter out the actions that are associated with a particular smart contract. The actions are grouped into blocks.</em></p>\n<p><em>You can open each action and see what it wrote into the storage, as well as the values it wrote in. Each action has a type, the time it took to write onto the storage, the path, and the value it wrote.</em></p>\n<p><em>This search does not contain all actions relevant to a smart contract. To see all actions relevant to a smart contract, one needs to view all actions executed within one block.</em></p>\n<p><em>With each block, you can find out what actions were performed during its application to the protocol. As you can see, there are many different actions occurring within the block. We also record the time needed to execute each action, allowing you to find out if an action (reading or writing) is slow or fast, therefore figuring out whether the performance is good or not.</em></p>\n<p>Explorer2.gif</p>\n<p><em>This animation demonstrates searching by block. In this particular case, the block contained a smart contract.</em></p>\n<p><em>Of particular interest is how the smart contract interacts with _BigMaps</em>. The BigMap container is a special map whose storage is only read or written per key on demand. They can be used as storage for addresses and their balances in smart contracts that operate in security token offerings (STOs)._</p>\n<p><em>In the future, we will add more search categories. In later articles, we will cover more types of actions that are performed within the block.</em></p>\n<p><strong>How it works</strong></p>\n<p>We have edited the Tezos code on the level where it reads from and writes into the storage. This way, we can capture operations made above the storage, including: write, read, delete, check out and commit.</p>\n<p>For instance, we can capture the <strong>write</strong> action and see into which key the action writes into, as well as the value that is recorded into the key.</p>\n<p>From the OCaml-based native node, the actions are sent back into the Rust-based TezEdge node. By default, it was not possible to view what a smart contract wrote into the storage, it was only possible to see the result. Now you can see everything that is being written into or read from the Tezos storage, as well as other operations above the storage layer.</p>\n<p>We did this by editing the Tezos OCaml code and creating an additional layer above the storage that sends actions into the Rust-based TezEdge node. Actions performed above the storage such as update, read, copy and delete are saved into our database.</p>\n<p>We are using a combination of RocksDB and commit log storage. In the commit log, we are storing the data of the actions and in RocksDB key-value store, we store only a reference to the data in commit log. Because we need to have multiple ways to look at the data, this approach helps us to save significant storage space. If we always made a copy of actions for each view we need we will be copying data over and over. With our approach, by using only pointers to commit log, we consume only 2 * 8 = 16 bytes per value stored in key-value store.</p>\n<p>We’re also working on decoding the binary data. We will be able to decode the binary data from the Ocaml storage, translating it into numbers and strings. At the moment, we’re able to decode a significant part of the data. Our goal is to decode all of the binary data from the OCaml node.</p>\n<p>The TezEdge Explorer is still in an early alpha stage at this point, but it already provides a new insight into the inner workings of the storage module in Tezos.</p>","frontmatter":{"date":null,"title":"Explorer","sidebar":"Docs","showTitle":false,"hideAnchor":null}}},"pageContext":{}}}