{"componentChunkName":"component---src-templates-post-template-js","path":"/tezedge/endpoints","result":{"data":{"markdownRemark":{"fields":{"slug":"/tezedge/endpoints"},"id":"0d1022e3-1245-568b-a1b9-4e8324986935","html":"<h1 id=\"endpoints-rpc\" style=\"position:relative;\"><a href=\"#endpoints-rpc\" aria-label=\"endpoints rpc permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Endpoints (RPC)</h1>\n<p>Whenever you are developing any kind of software, you need to ensure it can communicate with the outside world. One way of accessing and receiving data is through remote procedure calls (RPCs).</p>\n<p>The RPC is a basic json endpoint that a user calls to receive data. Imagine it as a communication channel that allows you to contact a remote service to send or request data.</p>\n<p>Our primary goal in the design of a new Tezos node is to achieve the highest degree of security. That being said, we have to consider the fact that some modules have to operate at a fast speed in order to provide good service for our users.</p>\n<p>During the development of the RPC module, we had to consider the node’s architecture which is based on the actor model. The actor model is a conceptual design that can be used to increase the security and resilience of a system. Each module in the node is separated from the others. In case of an error, the problem is limited to the faulty module. We can restart the faulty module and recover using the most recent valid state. Therefore the error does not spread to other modules in the node.</p>\n<p>Initially, we wanted to implement the actor model for RPCs as well. The RPC server would be another actor and when we requested data it did so by communicating with the other actors (network actor, storage actor and so on).</p>\n<h1 id=\"fine-tuning-for-latency-and-throughput\" style=\"position:relative;\"><a href=\"#fine-tuning-for-latency-and-throughput\" aria-label=\"fine tuning for latency and throughput permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fine-tuning for latency and throughput</h1>\n<p>We ran performance tests that involved a large number of requests at a time. The primary purpose of these tests was to optimize for latency, and the secondary goal was to increase throughput.</p>\n<p>We found out that actor model model was not ideal for RPC communication because while it does provide excellent error resiliency, the service on the side of the end-user is not as fast as we wanted it to be.</p>\n<p>This is because communication between actors adds a marginal amount of latency. When this marginal amount is multiplied by increasing the number of requests per minute, the latency stacks up and creates considerable lag.</p>\n<p>For this reason, we decided to not use the actor model in the RPC (although we still use it for the other modules). Instead, we began to read directly from the embedded database. Essentially, we cut out the middleman, thus reducing latency.</p>\n<h1 id=\"the-technology-involved\" style=\"position:relative;\"><a href=\"#the-technology-involved\" aria-label=\"the technology involved permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The technology involved</h1>\n<ul>\n<li>We are using the <strong>Tokio</strong>, an open source Rust library that is an implementation of the async runtime. </li>\n<li>On top of Tokio we are using <strong>Hyper</strong>, a library that processes http requests and responses.</li>\n</ul>\n<p>If you are building your own node and want to figure out if it is performing well, we advise you to run a performance test that involves the maximum amount of outgoing connections. In other words, not one but 30 or more requests at a time, also measuring how many are being sent out per minute. If there is a small latency with one request, this latency will stack up with multiple requests and slow down the entire system significantly. </p>\n<p>The RPC data is stored in the database in a way that allows for it to be quickly retrieved. Our storage has been designed for the quickest possible <em>select</em> function. </p>\n<p>There is still work to be done, especially concerning the database’s key value store.</p>\n<p>There are two methods that can be implemented:</p>\n<ol>\n<li>Every piece of data is always tied locally onto its key. Therefore Key A will retrieve Data A, Key B will retrieve Data B and so on. This option is faster than the next option but if you need to have multiple indexes all your data has to be duplicated multiple times.</li>\n<li>Keys only contain references to data. Data itself is stored in a commit log storage. This helps to save a lot of space, because data is not duplicated, but retrieval of data is a little bit slower because after finding a correct location by querying the key-value store you have to retrieve your data from the commit log store.</li>\n</ol>\n<p>We chose the second method because data stored in blockchain can take a considerable amount of space and duplicating it multiple times would take too much space. For most RPC requests the latency introduced by retrieving the data from commit log is very small and can even be improved by loading data in bulks. This helped us to achieve very low latencies and to support huge workloads.</p>\n<p>Although we did not utilize the actor model in the RPC module, it is used in other parts of the node and remains to be an integral part of our software architecture. We are preparing an article in which we will describe the actor model and its usefulness in concurrent programming. In the meantime, you can read more about Tezos and the TezEdge node by subscribing to our Medium, giving us a follow on Twitter or visiting our GitHub.</p>","frontmatter":{"date":null,"title":"Endpoints (RPC)","sidebar":"Docs","showTitle":false,"hideAnchor":null}}},"pageContext":{}}}