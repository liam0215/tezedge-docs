{"componentChunkName":"component---src-templates-post-template-js","path":"/introduction/tezos","result":{"data":{"markdownRemark":{"fields":{"slug":"/introduction/tezos"},"id":"1681160c-902a-564e-b9e8-d77adc54ee19","html":"<h1 id=\"tezos\" style=\"position:relative;\"><a href=\"#tezos\" aria-label=\"tezos permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tezos</h1>\n<h2 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h2>\n<p>The purpose of Tezos is to create an eternal blockchain. One of the core issues in blockchain is the destructive nature of forking. This is why Tezos has been developed as a self-amending blockchain that avoids hard forks.</p>\n<h2 id=\"self-amendment\" style=\"position:relative;\"><a href=\"#self-amendment\" aria-label=\"self amendment permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Self amendment</h2>\n<p>The main advantage of the Tezos blockchain is the ability to self amend. Instead of changing the protocol by forking into a different version, change is made from within the Tezos ecosystem. </p>\n<p><strong>Why self amendment?</strong></p>\n<ul>\n<li><strong>Explicit governance</strong>: Avoids never-ending debates (e.g. block size, hard forks)</li>\n<li><strong>Rewards innovation</strong>: Incentivizes collaboration instead of competition</li>\n<li><strong>Avoids plagiarism</strong></li>\n<li><strong>Solves collective action problems</strong>: A block reward is a solution for a collective action problem.</li>\n<li><strong>Introduces security into the system, builds and maintains infrastructure.</strong></li>\n<li>It fosters <strong>coordination.</strong></li>\n<li><strong>Super-nash equilibrium</strong> - no one benefits from deviating from the strategy. The most famous example is the <em>prisoner’s dilemma</em> - defection is in the individual’s  interest, but the best solution is to cooperate. </li>\n<li>Digging tunnels to <strong>Pareto optimality</strong> - there is a solution to a problem and there cannot be a better solution without making anyone worse off - therefore it is considered fair.</li>\n</ul>\n<p>By changing from the inside, there will be changes to the code, but they're going to come from the blockchain itself. </p>\n<p><strong>How is that accomplished?</strong> The <em>apply</em> function and the <em>fitness</em> functions are put inside the states that are modified, so now the state of our blockchain is also going to contain the function itself instead of just containing the set of balances or the total amount of work. </p>\n<p>There is a new type of operation called an <em>amendment</em> which can modify, so now it is possible to submit operations which modify the rules of the ledger in addition to making transactions. To achieve this, the amendments have the option of introspecting into protocols. One can make changes to <em>apply</em>, but for the operation to be valid, they can require some structure on <em>apply.</em> </p>\n<p>The apply function cannot be replaced with just any function. The apply function must have certain properties. </p>\n<p>Self amendment gives us <strong>explicit governance.</strong> It provides a very specific operation with very specific rules, such as voting, for example, which would let us change the protocol and that's like having the rule of law. </p>\n<p>There's been a lot of contentious debates in certain cryptocurrencies about the block size or  hard forks. The problem with contentious debate is that if there isn't a hard rule to go by, then it can carry on forever. Tezos strives to reward innovation right away—if someone has a great idea about blockchain, then they usually have to start their own blockchain since most people aren’t motivated into contributing to an existing one. Tezos fosters an environment which rewards innovation. If there is a breakthrough idea, anyone can submit it to the Tezos protocol.</p>\n<h2 id=\"emmy-liquid-proof-of-stake\" style=\"position:relative;\"><a href=\"#emmy-liquid-proof-of-stake\" aria-label=\"emmy liquid proof of stake permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Emmy⁠⁠: liquid proof of stake</h2>\n<p>Tezos allows token holders to transfer (“delegate”) validation rights to other token holders without transferring ownership. In Tezos, delegation is optional. The Tezos consensus mechanism as “Liquid Proof-of-Stake” to maintain a dynamic validator set, facilitating token holder coordination and accountable governance.</p>\n<ul>\n<li>It is an algorithm that proceeds in cycles.</li>\n<li>A cycle is a set of blocks, 4096 blocks(slots)</li>\n<li>Each slot is separated by at least a minute.</li>\n<li>A slot comes up and a baker (a block producer in Tezos) creates a block. If they are honest, they will attach it to the end of the chain.</li>\n<li>Another baker comes in and creates a block, repeated until the end of the cycle</li>\n<li>For robustness, once a baker create a block they will want to prove that they created it, malicious players do not want to claim the creation of a block.</li>\n<li>32 stakeholders are randomly selected (select 32 token values and look up who owns them), these are going to get endorsement rights and are known as endorsers.</li>\n<li>Whenever a baker creates a block, there are endorsers waiting to see who made the block and approve it. They sign the block (submit signatures), creating a new block and the process is repeated.</li>\n</ul>\n<p><strong>Generating randomness</strong> </p>\n<p>Since Tezos runs a deterministic protocol, there is no randomness. </p>\n<p>In proof of work, the randomness is external in the sense that if a proof of work task is being hashed, it focuses on partial collision and not the rest. The rest provides a lot of randomness that is very difficult to optimize for.</p>\n<p>Tezos uses a <em>commit reveal scheme</em> to generate entropy. Different people commit to a random number and then reveal it at a later time. Different trivial numbers are used to create entropy. A cycle begins and rights are assigned. The score of the chain is going to be the total number of endorsements on the chain. </p>\n<p><strong>Baker safety deposits</strong></p>\n<p>Baker and endorsers have to place safety deposits. This is done in order to discourage equivocation (when someone creates two blocks at the same height), since Tezos wants people to commit to one version.</p>\n<p>Before a baker creates a block, they make a deposit. Then the baker creates the block and if anyone (particularly endorsers) see that they created two blocks at the same height, they can report this and the baker will lose their deposit. </p>\n<p>The safety deposits ensure that anyone is who is participating in the system (producing blocks, endorsing) is actually holding tokens and, in some sense, has the network’s best interests at heart. </p>\n<p><strong>Advantages</strong> </p>\n<ul>\n<li>\n<p><strong>Quick convergence to consensus</strong> </p>\n<p>When endorsers are reactive, after a few blocks, a substantial fraction of the ownership base has been selected, and if they all agree on this history, they are unlikely to depart.</p>\n</li>\n<li>\n<p><strong>Good liveness</strong> </p>\n<p>The blockchain will always be making progress. Even if some participants are not reactive, new transactions and new blocks will continue to be created.</p>\n</li>\n<li>\n<p><strong>Fair block creation rights</strong> </p>\n<p>The creation of blocks is proportionate to the stake a person owns in Tezos. If someone owns 1% of the tokens, they should be able to make 1% of the blocks.</p>\n</li>\n</ul>\n<p><strong>Disadvantages</strong></p>\n<ul>\n<li>\n<p><strong>No finality</strong></p>\n<p>It is impossible to know whether a transaction has been permanently included in the ledger. Perhaps somebody has come up with a longer chain, or a better chain. Statistically, it is likely that a user's version of the chain will change.</p>\n</li>\n<li>\n<p><strong>Synchronicity assumption</strong></p>\n<p>There is a reason why we wait a minute and not a second. For the system to work, an honest majority is needed, but if people begin delaying blocks, then all of a sudden the honest majority needs to become much larger. If an individual can delay every message by 2 minutes and they control 33% of the network, then they are going to create blocks at a slower speed, but if they can slow the speed of the other bakers (the users who create blocks), then they are going to go at the same speed as everyone else. If an individual can delay the process by 2 minutes, then the network must have a 66% honest majority.</p>\n</li>\n</ul>\n<h2 id=\"smart-contracts-in-tezos\" style=\"position:relative;\"><a href=\"#smart-contracts-in-tezos\" aria-label=\"smart contracts in tezos permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Smart contracts in Tezos</h2>\n<p>When it comes to smart contracts, the usual approach is to create a virtual machine (VM). Developers program their contracts in a high-level language and then they will compile it down to the VM. </p>\n<p><strong>Advantages</strong></p>\n<p>It is possible to count the cost very easily by counting the steps in the VM and it's very generic. A developer can simply compile all the languages they want into a very simple and minimal VM.</p>\n<p><strong>Disadvantages</strong></p>\n<p>However, this can be a problem in case a developer wants to really understand what they're doing. First, they need the formal specification of the VM. For a VM, that's not hard to get, but a formal specification of the high-level language is also needed. It is also necessary to have a formally verified compiler that makes sure the contract is performing as intended. This is because these contracts can hold cryptocurrency worth 100s of millions of Euros, so the cost of error in these contracts is very high. It is impossible to change the smart contracts once they're deployed, so the cost of errors can be enormous.</p>\n<h1 id=\"smart-contract-design\" style=\"position:relative;\"><a href=\"#smart-contract-design\" aria-label=\"smart contract design permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Smart contract design</h1>\n<p><strong>Correctness</strong> </p>\n<p>It is crucial to avoid errors. While verifiability is important, it is also necessary to be able to prove to everyone that the smart contracts in Tezos do not have any issues. It's not enough for the developer to be confident, everyone else needs to be confident as well. </p>\n<p><strong>Parsimony</strong></p>\n<p>Space is expensive on the blockchain, it is valued as a premium and everyone needs to keep everything that's on a blockchain on their disk (or even in memory, if efficiency is a priority), therefore it is better to avoid space-intensive smart contracts. </p>\n<p><strong>Performance</strong> </p>\n<p>Performance is not an issue since smart contracts run on simple logic. </p>\n<p><strong>Portability</strong> </p>\n<p>Portability isn’t an issue either, since the smart contracts perform reading on the Tezos blockchain. It is not necessary to run them on a dozen different platforms. </p>\n<h2 id=\"designing-the-language-of-tezos\" style=\"position:relative;\"><a href=\"#designing-the-language-of-tezos\" aria-label=\"designing the language of tezos permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Designing the language of Tezos</h2>\n<ul>\n<li><strong>Generic</strong><br>\nIt should be generic so that developers are able to do anything they want to. It wouldn't be smart to begin with a domain-specific language for contracts or finance. Smart contracts can be used for many different things and therefore it is not good to have a too strong of a view of what their language will be used for. </li>\n<li><strong>Safe</strong><br>\nThe language must be safe, and that means it is at the very least type safe.</li>\n<li><strong>Readable</strong><br>\nIt must also be really bold because developers and other interested parties will look at the contracts and try to understand what is happening inside them.</li>\n<li><strong>Easy gas accounting</strong><br>\nIt is good to be able to count the resources that the contract is using durign its execution.  </li>\n</ul>\n<p>There's a slight conflict here, because some people may be interested in an assembly-like generic language with easy gas accounting — they want the VM approach. However, others may prefer something safe and readable-a high-level functional language.</p>\n<h1 id=\"michelson\" style=\"position:relative;\"><a href=\"#michelson\" aria-label=\"michelson permalink\" class=\"post-toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Michelson</h1>\n<p>Michelson is the programming language used to write smart contracts on the Tezos blockchain. </p>\n<p>Michelson is a strongly-typed, stack-based language with high level primitives and strict static type checking. The types of Michelson are composable, so complex data can be annotated by one large type. </p>\n<p>Michelson does not contain features such as polymorphism, closures, or named functions. A high-level programming called Liquidity can be written and compiled to the Michelson programming language. Developers can prove properties in their smart contracts through a formal verification process.  A Michelson program is a series of instructions that are run in sequence: each instruction receives the stack resulting of the previous instruction as an input, and then rewrites it for the next instruction. The stack contains both immediate values and heap allocated structures. All values are immutable and garbage collected. </p>\n<p>A Michelson program receives as input a stack containing a single pair whose first element is an input value and second element the content of a storage space. It must return a stack containing a single pair:</p>\n<ul>\n<li>The first element is a list of internal operations</li>\n<li>The second element the new contents of the storage space.</li>\n</ul>\n<p>Alternatively, a Michelson program can fail, explicitly using a specific opcode, or because there was an error that wasn’t picked up by the type system (e.g. division by zero, gas exhaustion etc.).</p>\n<p>The types of the input, output and storage are fixed and monomorphic, and the program is typechecked before being introduced into the system. No smart contract execution can fail because an instruction has been executed on a stack of unexpected length or contents.</p>\n<p>This specification gives the complete instruction set, type system and semantics of the language. It is meant as a precise reference manual, not an easy introduction. Even though, some examples are provided at the end of the document and can be read first or at the same time as the specification.</p>\n<p>The Michelson programming language is unlike any other and it is almost like a virtual machine’s operation code. Although it is possible to hand-type Michelson, it is not necessary. Instead, simply write in a high-level programming language (such as Liquidity or fi) that compiles into Michelson.</p>","frontmatter":{"date":null,"title":"Tezos","sidebar":"Docs","showTitle":false,"hideAnchor":null}}},"pageContext":{}}}